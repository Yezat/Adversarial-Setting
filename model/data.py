"""
This module defines classes to generate data models and sample data for the experiments.
"""

import logging
import numpy as np
from dataclasses import field, dataclass
from typing import Callable, Any

DataModelFactoryType = Callable[
    ..., tuple[np.ndarray, np.ndarray, np.ndarray, np.ndarray, np.ndarray]
]


@dataclass
class DataModel:
    """
    Data class for data models.

    Attributes:
        d (int): Dimension of the space.
        gamma (float): The aspect ratio of the student space to the teacher space p/d = 1.
        name (str): Optional name of the model, if defined. The pickle file name will contain this name. If the file already exists, an exception will be thrown.
        description (str): Optional description of the model, just a text to describe in words what the model is about.
        Σ_x (ndarray): The data covariance.
        Σ_ω (ndarray): The student weight prior (d,d).
        Σ_δ (ndarray): The student adversarial budget (d,d).
        Σ_ν (ndarray): The student adversarial budget (d,d).
        Σ_θ (ndarray): The teacher weight prior (d,d).
        θ (ndarray): The teacher weight prior (d,).
        ρ (float): The teacher-teacher overlap.
        ΦΦT (ndarray): The Σ_x^T θ θ^T Σ_x matrix (d,d).
        spec_ΦΦT (ndarray): The spectrum of ΦΦT (d,).
        spec_Σ_x (ndarray): The spectrum of Σ_x (d,).
        spec_Σ_δ (ndarray): The spectrum of Σ_δ (d,).
    """

    d: int
    normalize_matrices: bool

    data_model_factory: DataModelFactoryType = None
    data_model_factory_name: str = None
    factory_kwargs: dict[str, Any] = field(default_factory=dict)

    name: str = ""
    description: str = ""
    gamma: float = 1

    Σ_x: np.ndarray = field(init=False, repr=False)
    Σ_ω: np.ndarray = field(init=False, repr=False)
    Σ_δ: np.ndarray = field(init=False, repr=False)
    Σ_ν: np.ndarray = field(init=False, repr=False)
    θ: np.ndarray = field(init=False, repr=False)

    Σ_θ: np.ndarray = field(init=False, repr=False)
    ρ: float = field(init=False, repr=False)
    ΦΦT: np.ndarray = field(init=False, repr=False)
    spec_ΦΦT: np.ndarray = field(init=False, repr=False)
    spec_Σ_x: np.ndarray = field(init=False, repr=False)
    spec_Σ_δ: np.ndarray = field(init=False, repr=False)

    def __post_init__(self) -> None:
        self.data_model_factory_name = self.data_model_factory.__name__

    def __repr__(self) -> str:
        return f"DataModel(d={repr(self.d)}, normalize_matrices={repr(self.normalize_matrices)}, data_model_factory={self.data_model_factory.__name__}, factory_kwargs={repr(self.factory_kwargs)}, name={repr(self.name)}, description={repr(self.description)}, gamma={repr(self.gamma)})"

    @classmethod
    def from_dict(cls, data) -> "DataModel":
        k_features_factory_names = {
            "x_diagonal",
            "θ_diagonal",
            "ω_diagonal",
            "δ_diagonal",
            "ν_diagonal",
        }

        kwargs = data["factory_kwargs"]

        match kwargs:
            case _ if any(key in k_features_factory_names for key in kwargs):
                matching_keys = [
                    key for key in kwargs if key in k_features_factory_names
                ]
                for key in matching_keys:
                    data["factory_kwargs"][key] = KFeaturesDefinition.from_dict(
                        kwargs[key]
                    )

        data["data_model_factory"] = globals()[data["data_model_factory_name"]]

        logging.info(data)

        return cls(**data)

    def generate_model_matrices(self) -> None:
        """
        Computes more attributes. Has to be called prior to using the data model instance. It's not called automatically in __post_init__ to save memory at definition time.

        Assumes that
        - Σ_x
        - θ
        - Σ_ω
        - Σ_δ
        - Σ_ν

        can be generated by the factory function.
        """
        logging.info("Initializing data model")

        self.Σ_x, self.θ, self.Σ_ω, self.Σ_δ, self.Σ_ν = self.data_model_factory(
            self.d, **self.factory_kwargs
        )

        # Check if the matrices are positive semi-definite
        assumption_1 = self.Σ_x - self.Σ_x.T @ np.linalg.inv(self.Σ_x) @ self.Σ_x
        min_eigval = np.min(np.linalg.eigvals(assumption_1))
        if min_eigval < 0:
            logging.warning(
                f"Assumption on Schur Complement failed: Matrix was not positive semi-definite; min eigval: {min_eigval}"
            )

        logging.info(f"d: {self.d}")

        # Compute Σ_θ
        self.Σ_θ = np.diag(self.θ)

        # Normalize all the matrices by dividing by the norm of the matrix
        logging.info(f"normalize_matrices: {self.normalize_matrices}")
        if self.normalize_matrices:
            logging.info("Normalizing the matrices")
            self.Σ_x = self.Σ_x / np.trace(self.Σ_x) * self.d
            self.Σ_ω = self.Σ_ω / np.trace(self.Σ_ω) * self.d
            self.Σ_δ = self.Σ_δ / np.trace(self.Σ_δ) * self.d
            self.Σ_ν = self.Σ_ν / np.trace(self.Σ_ν) * self.d
            self.Σ_θ = self.Σ_θ / np.trace(self.Σ_θ) * self.d

        self.spec_Σ_x = np.linalg.eigvals(self.Σ_x)
        self.spec_Σ_θ = np.linalg.eigvals(self.Σ_θ)

        # compute and log the ratio of the first eigenvalue to the last eigenvalue
        logging.info(
            f"Ratio of first to last eigenvalue of Σ_x: {self.spec_Σ_x[0] / self.spec_Σ_x[-1]}"
        )

        # Compute ΦΦT
        self.ΦΦT = np.diag(self.spec_Σ_x**2 * self.spec_Σ_θ)

        # Compute ρ
        self.ρ = np.mean(self.spec_Σ_x * self.spec_Σ_θ)

        # Compute FTerm
        self.FTerm = self.Σ_x.T * self.Σ_θ * self.Σ_ν + self.Σ_ν.T * self.Σ_θ * self.Σ_x

        # compute the spectra
        self.spec_ΦΦT = np.linalg.eigvals(self.ΦΦT)
        self.spec_Σ_δ = np.linalg.eigvals(self.Σ_δ)
        self.spec_Σ_ω = np.linalg.eigvals(self.Σ_ω)
        self.spec_Σ_ν = np.linalg.eigvals(self.Σ_ν)
        self.spec_FTerm = np.linalg.eigvals(self.FTerm)

        # log the spectra
        logging.info(f"Norm Σ_x: {np.trace(self.Σ_x)}")
        logging.info(f"Norm Σ_ω: {np.trace(self.Σ_ω)}")
        logging.info(f"Norm Σ_δ: {np.trace(self.Σ_δ)}")
        logging.info(f"Norm Σ_ν: {np.trace(self.Σ_ν)}")
        # log entries of Σ_x
        logging.info(f"Σ_x: {self.Σ_x}")
        logging.info(f"Σ_ω: {self.Σ_ω}")
        logging.info(f"Σ_δ: {self.Σ_δ}")
        logging.info(f"Σ_ν: {self.Σ_ν}")

        # value count the entries of Σ_x
        logging.info(f"Σ_x value counts: {np.unique(self.Σ_x, return_counts=True)}")
        logging.info(f"Σ_ω value counts: {np.unique(self.Σ_ω, return_counts=True)}")
        logging.info(f"Σ_δ value counts: {np.unique(self.Σ_δ, return_counts=True)}")
        logging.info(f"Σ_ν value counts: {np.unique(self.Σ_ν, return_counts=True)}")

        # log ρ
        logging.info(f"ρ: {self.ρ}")

        # log the spec_Σ_δ
        logging.info(f"Σ_δ eigenvalues: {self.spec_Σ_δ}")

        # Assert that the shapes of the matrices are correct
        assert self.Σ_x.shape == (self.d, self.d)
        assert self.Σ_θ.shape == (self.d, self.d)
        assert self.Σ_ω.shape == (self.d, self.d)
        assert self.Σ_δ.shape == (self.d, self.d)
        assert self.Σ_ν.shape == (self.d, self.d)


@dataclass
class KFeaturesDefinition:
    """
    This dataclass specifies KFeatures diagonal matrices.
    """

    diagonal: list[tuple[int, int]] = field(
        default_factory=list
    )  # list of tuples (feature_value, feature_size)

    @classmethod
    def from_dict(cls, data) -> "KFeaturesDefinition":
        return cls(**data)

    def get_nd_array(self, d: int) -> np.ndarray:
        """
        Returns the diagonal matrix of the KFeaturesModel.
        """
        v = np.zeros(d)
        c = 0
        for feature_value, feature_size in self.diagonal:
            v[c : c + feature_size] = feature_value
            c += feature_size
        return v

    def get_nd_matrix(self, d: int) -> np.ndarray:
        return np.diag(self.get_nd_array(d))


def k_features_factory(
    d: int,
    x_diagonal: KFeaturesDefinition,
    θ_diagonal: KFeaturesDefinition,
    ω_diagonal: KFeaturesDefinition,
    δ_diagonal: KFeaturesDefinition,
    ν_diagonal: KFeaturesDefinition,
) -> tuple[np.ndarray, np.ndarray, np.ndarray, np.ndarray, np.ndarray]:
    """
    Factory function for KFeaturesModel.
    """
    Σ_x = x_diagonal.get_nd_matrix(d)
    Σ_ω = ω_diagonal.get_nd_matrix(d)
    Σ_δ = δ_diagonal.get_nd_matrix(d)
    Σ_ν = ν_diagonal.get_nd_matrix(d)
    θ = θ_diagonal.get_nd_array(d)
    return Σ_x, θ, Σ_ω, Σ_δ, Σ_ν


def k_features_defend_orthogonal_teacher_factory(
    d: int,
    seed: int,
    x_diagonal: KFeaturesDefinition,
    θ_diagonal: KFeaturesDefinition,
    ω_diagonal: KFeaturesDefinition,
    std: float = 0.0001,
    noise_level: float = 10000,
):
    """
    Factory function for a KFeaturesModel with a defence in the orthogonal direction of the teacher.
    """
    rng = np.random.default_rng(seed=seed)

    vprime = rng.normal(0, 1, d)

    # chose v = vprime - <vprime,θ> θ / ||θ||^2

    θ = θ_diagonal.get_nd_array(d)

    v = vprime - np.dot(vprime, θ) * θ / np.linalg.norm(θ) ** 2

    # normalize v
    Σ_δ_content = v / np.linalg.norm(v)

    # Only for the Optimal Defense Experiment
    Σ_δ = np.outer(Σ_δ_content, Σ_δ_content)

    # sample a random covariance matrix
    random_matrix = rng.normal(0, std, (d, d))
    Σ_δ = random_matrix.T @ random_matrix + Σ_δ * noise_level

    Σ_x = x_diagonal.get_nd_matrix(d)
    Σ_ω = ω_diagonal.get_nd_matrix(d)
    Σ_ν = Σ_δ.copy()
    return Σ_x, θ, Σ_ω, Σ_δ, Σ_ν
